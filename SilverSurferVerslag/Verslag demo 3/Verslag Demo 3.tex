%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                                                     %%%
%%%   LaTeX template voor het verslag van P&O: Computerwetenschappen.   %%%
%%%                                                                     %%%
%%%   Opties:                                                           %%%
%%%     tt1     Tussentijdsverslag 1                                    %%%
%%%     tt2     Tussentijdsverslag 2                                    %%%
%%%     tt3     Tussentijdsverslag 3                                    %%%
%%%     eind    Eindverslag                                             %%%
%%%                                                                     %%%
%%%   2 oktober 2012                                                    %%%
%%%   Versie 1.0                                                        %%%
%%%                                                                     %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[tt3]{penoverslag}

%%% PACKAGES
\usepackage{lipsum}
\usepackage{gensymb}
\usepackage [dutch] {babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{subcaption}

\begin{document}

% == VOORPAGINA == %
\team{Zilver} % teamkleur
\members{Sam Gielis\\
         Sophie Marien\\
         Toon Nolten\\
         Nele Rober\\
         Gerlinde Van Roey\\
         Maxim Van Mechelen} % teamleden

\maketitlepage

% == ABSTRACT EN INHOUDSTAFEL == %
\begin{abstract}
\label{ssec:abstr}
De robot wordt voor demo 1 nog niet voorzien van sensoren. De focus ligt vooral op de nauwkeurigheid van de besturing en op het implementeren van alle softwarecomponenten. Deze software bestaat uit twee projecten: een op de computer en een op de robot. De computersoftware bestaat uit een Grafical User Interface (GUI), enkele Communication klassen die informatie doorsturen en enkele klassen die de werking van de robot simuleren (simulator).
Voor demo 2 worden de sensoren wel op de robot geplaatst. Nadat ze gecalibreerd zijn, kunnen ze informatie doorzenden naar de robot. Er zijn twee threads, \'e\'en die de sensoren uitleest en een ander die de informatie ontvangt en opslaagt in de \item \textit{infoStatusBuffer:}. 
Er is een lichtsensor en een ultrasone sensor. 

\end{abstract}

\tableofcontents

%figuur robot
\begin{figure}[!b]
\begin{flushright}
    \includegraphics[width=1\textwidth]{robotFP2}
    \label{fig:robotFP}
\end{flushright}
\end{figure}


\newpage 

% == INLEIDING == %
\section{Inleiding} % ok demo2!
\label{ssec:inl}
In het kader van het vak 'Probleemoplossen en Ontwerpen: computerwetenschappen' wordt gewerkt rond autonome intelligente robots. Verschillende teams bouwen en programmeren een robot met behulp van LEGO Mindstorms. Deze robot moet uiteindelijk volledig autonoom een doolhof kunnen verkennen.
Op de tweede demonstratie kan de robot alle taken van de vorige demonstratie nog steeds uitvoeren. De robot kan autonoom een witte lijn zoeken in het doolhof en kan zich hier loodrecht op ori\"enteren. De GUI laat toe de sensorwaarden van de robot te lezen; via deze waarden kan een bestuurder het doolhof tekenen zonder het doolhof te zien.
De simulator is in staat dezelfde demonstratie te tonen.

% == BOUW == %
\section{Bouw van de robot} % ok demo2!
\label{sec:bouw}
LEGO Mindstorms\footnote{\textit{Lego Mindstorms}:  Een uitbreiding op de LEGO bouwstenen waarmee kleine, aanpasbare en programmeerbare robots gebouwd kunnen worden. Een centrale besturingsmodule ('the brick') kan geprogrammeerd worden met verschillende programmeertalen. In eerdere versies werd een RCX gebruikt voor de brick, nu wordt met NXT gewerkt. De brick kan enkele motoren aandrijven. Bovendien kunnen er verschillende sensoren, o.a. een ultrasone sensor en een lichtsensor, aangesloten worden.  \mbox{[www.lego.com]} \mbox{[http://en.wikipedia.org/wiki/Lego\textendash Mindstorms]}} biedt een bouwpakket voor een robot aan. Een NXT-microcomputer laat toe de robot te programmeren met Java.

% == fysieke bouw == %
\subsection{Fysieke bouw} % tekst: ok demo2! foto nog niet
\label{ssec:fysbouw}
Bij het bouwen van de robot (zie figuur \ref{robot}) werd het ontwerpboekje gevolgd dat bij het bouwpakket geleverd zat. Deze compacte samenstelling leek geen directe nadelen te hebben. Twee grote wielen worden elk met hun eigen motor aangestuurd. Kleine wielen achteraan zorgen voor meer stabiliteit en worden niet aangedreven. De sensoren werden als volgt ge\"implementeert: 

\begin{itemize}
\item \textit{lichtsensor:} vooraan en dicht tegen de grond.
\item \textit{ultrasone sensor:} bovenaan, naar voren kijkend. De sensor staat vast gemonteerd.
\item \textit{druksensoren:} aan beide zijkanten, \'e\'en aan de linkerkant en \'e\'en aan de rechterkant.
\end{itemize}

%figuur robot
\begin{figure}[tbp]
\begin{center}
    \includegraphics[width=0.8\textwidth]{robot}
    \caption{Robot}
    \label{robot}
\end{center}
\end{figure}


% figuur sensoren
\begin{figure}
        \centering
        \begin{subfigure}[h]{0.48\textwidth}
                \centering
                \includegraphics[width=\textwidth]{robotUS}
                \caption{Ultrasone sensor}
                \label{fig:US}
        \end{subfigure}%
        \begin{subfigure}[h]{0.48\textwidth}
                \centering
                \includegraphics[width=\textwidth]{robotLSTS}
                \caption{Licht- en Druksensor}
                \label{fig:LS+TS}
                \end{subfigure}
        \label{fig:sensors}
\end{figure}


Een alternatieve opstelling bestaat erin de NXT plat te leggen met ernaast de twee grote wielen. Op deze manier kan de ultrasone sensor op een extra motor gemonteerd worden zodat onafhankelijk van de robot kan ronddraaien. Deze opstelling vraagt echter om een nieuwe calibratie. Bovendien kan deze opstelling tot extra afrondingsfouten leiden. Omdat het voorlopig niet noodzakelijk is dat de ultrasone sensor kan ronddraaien, werd niet voor deze opstelling gekozen.


% == calibratie == %
\subsection{Calibratie van de motoren} % inleiding ok demo2! rest nog niet
\label{ssec:calibM}
De robot wordt aangedreven door twee motoren, elk verbonden met \'e\'en van de twee wielen. De aansturing gebeurt door te bepalen hoeveel graden de wielen moeten draaien. Beide wielen kunnen onafhankelijk ingesteld worden. De robot kan \'e\'en cm vooruit bewegen (beide wielen draaien x aantal graden in dezelfde richting) en rond zijn as (beide wielen draaien y aantal graden in tegengestelde richting). De resultaten van de calibratie worden weergegeven in tabel \ref{tab:resultCalibM}. Het bepalen van parameters x en y gebeurt als volgt:

%resultaten meetwaarden
\begin{table}[hb]
\begin{center}
    \begin{tabular}{  l || c | c | c }
     & linkerwiel & rechterwiel & aantal graden \\ \hline \hline
    1 cm vooruit & voor & voor & 20,8\degree
    \\ \hline
    1 cm achteruit & achter & achter & 20,8\degree
    \\ \hline
    180\degree draaien linksom & achter & linker & 701\degree \\ \hline
    180\degree draaien rechtsom & voor & achter & 701\degree \\
    \end{tabular}
    \caption{Resultaten calibratie motoren}
    \label{tab:resultCalibM}
\end{center}
\end{table}



\subsubsection{E\'en cm vooruit bewegen: bepalen van x} % nog na te kijken demo2! + meetwaarden!
\label{ssec:calibMx}
Een schatting voor x via de diameter van het wiel, waarbij x voor het aantal graden staat en de diameter in centimeter:

\begin{equation*}
x_{0} \approx \frac{360}{\pi \cdot diameter}
\end{equation*}

De parameter x kan verder bepaald worden via tests.
De robot rijdt naast een lintmeter 100 keer \'e\'en cm af. De wielen draaien met andere woorden 100 keer x graden. De totale afwijking (in centimeter) op deze volledige meter is de som van alle afwijkingen op \'e\'en centimeter. De afwijking op \'e\'en centimeter is voor elke centimeter gelijk. Een betere schatting van x wordt als volgt gegeven:

\begin{equation*}
x_{1} \approx \frac{360}{\pi \cdot diameter_{wiel}} \cdot \left(1-\frac{afwijking_{totaal}}{100}\right)
\end{equation*}

Door dit steeds te herhalen, wordt een steeds betere waarde voor x gevonden. De diameter en de afwijking zijn ook slechts benaderingen van de werkelijke waarden. 

\subsubsection{Volledig rond de as draaien: bepalen van y} % niet in orde demo2! + meetwaarden!
\label{ssec:calibMy}

Een schatting voor y via de diameter van het wiel, met y in aantal graden en de as (afstand tussen beide wielen) en de diameter in centimeter:

\begin{equation*}
y_{0} \approx \frac{(2 \cdot \pi) \cdot (as_{robot}/2)}{diameter_{wiel}/2}
\end{equation*}

Om de robot om zijn as te laten draaien, bewegen de beide wielen in tegengestelde richting. De robot wordt naast een lijn geplaatst. De parameter wordt aangepast tot de robot na het draaien opnieuw precies naast de lijn uitkwam.

\subsection{Calibratie van de lichtsensor} % niet in orde demo2! + meetwaarden!
\label{ssec:calibLS}
Verschillende waarden werden opgemeten met de lichtsensor in verschillende lichtomstandigheden.\\
meetwaarden en grafieken toevoegen: bvb grijskaart (dat zijn standaardkleuren) toevoegen en waarden van de sensor in verschillenden lichtsituaties

 %resultaten meetwaarden
\begin{table}[hb]
\begin{center}
\begin{tabular}{ r || c | c | c | c | c | c | c | c}
max & 56 & 55 & 56 & 55 & 55 & 50 & 50 & 50 \\ \hline
$Q_{0,75}$ & 56 & 55 & 55 & 55 & 50 & 49 & 50 & 50 \\ \hline
mediaan & 55 & 55 & 55 & 55 & 49 & 49 & 49 & 50 \\ \hline
$Q_{0,25}$ & 55 & 55 & 55 & 55 & 49 & 49 & 49 & 50 \\ \hline
min & 49 & 55 & 49 & 55 & 47 & 49 & 47 & 50
\end{tabular}
\caption{Resultaten}
\label{tab:result}
\end{center}
\end{table}

\subsection{Calibratie van de ultrasone sensor} % niet in orde demo2! + meetwaarden!
\label{ssec:calibUS}
Verschillende afstanden werden opgemeten voor de ultrasone sensor.\\
meetwaarden en grafieken toevoegen

\begin{table}[hb]
\begin{center}
    \begin{tabular}{  l || c | c  }
     & rechts & scheef  \\ \hline \hline
     32 & 32 & 32 \\
     32 & 32 & 33 \\
	    & 31 & 32 \\
	 32 & 32 & 32 \\
	 32 & 33 & 32 \\
	 33 & 32 & 32 \\
	 33 & 32 & 33 \\ \hline
     27 & 28 & 29 \\
     27 & 28 & 29 \\
     27 & 28 & 29 \\
     27 & 30 & 29 \\
     28 & 27 & 28 \\
     28 & 27 & 29 \\
    \end{tabular}
    \caption{Resultaten calibratie van de ultrasone sensor}
    \label{tab:resultCaliUltra}
\end{center}
\end{table}

% == ALGORITMES == %
\section{Algoritmes} % ok demo2!
\label{sec:algo}
Verschillende algoritmes zorgen ervoor dat de robot alle opdrachten kan uitvoeren.

% == veelhoek == %
\subsection{Het rijden van een veelhoek} % redelijk demo2!
\label{ssec:algoVeelH}
De robot en de simulator kunnen beiden een veelhoek rijden. Het aantal hoeken en de lengte van de zijden kunnen via de GUI ingesteld worden. De robot en de simulator rijden een afstand, draaien een bepaald aantal graden rond hun as, rijden weer dezelfde afstand,... Tot de volledige veelhoek gereden is. Enkele parameters zijn van belang:

\begin{itemize}
\item \textit{aantal keer dat de stappen moeten worden uitgevoerd, amtOfAngles:} aantal hoeken van de veelhoek.
\item \textit{afstand per stap, lengthInCM:} zijde van de veelhoek.
\item \textit{aantal graden per stap, angle:} 360 gedeeld door het aantal hoeken van de veelhoek.
\end{itemize}

Om een stap uit te voeren wordt een commando gestuurd naar de \textit{CommandToUnit}. Dit is een integer bestaande uit twee delen. De eenheden staan voor het soort commando. De tientallen en de honderdtallen geven aan hoeveel centimeter de robot vooruit moet bewegen of hoeveel graden hij moet draaien.

\lstset{frame=single, language=Java, caption=Veelhoek algoritme (pseudocode),
    	label=code:algoVeelH, numbers=left, numberstyle=\footnotesize,
		basicstyle=\sffamily, numbersep=5pt}
\begin{lstlisting}
AmtOfAngles
LengthInCM

Angle = (360.0/amtOfAngles)*100
Voor i van 0 tot amtOfAngles
	Beweeg lengthInCM vooruit
	Draai angle
\end{lstlisting}


% == witte lijn == %
\subsection{Het rechtzetten op een witte lijn} % redelijk demo2!
\label{ssec:algoWitteL}

De robot en de simulator kunnen zich loodrecht ori\"enteren op een witte lijn.
Het algoritme kan gebruikt worden wanneer de robot vlak bij een witte lijn staat (wanneer hij volledig rond zijn as draait zou hij de witte lijn moeten passeren). Het idee achter het algoritme (in pseudocode)

\lstset{frame=single, caption=Witte Lijn algoritme (pseudocode),
		label=code:algoWitteL, numbers=left, numberstyle=\footnotesize,
		basicstyle=\sffamily, numbersep=5pt}
\begin{lstlisting}
AngleTurned = 0
WheelAngle = 5

Draai naar rechts (wielen draaien WheelAngle graden).
Als op witte lijn: naar volgende stap.
Anders: naar vorige stap.

Draai naar links (wielen draaien WheelAngle graden)
	en verhoog AngleTurned met WheelAngle.
Als op witte lijn: naar volgende stap.
Anders: naar vorige stap.

Draai AngleTurned/2 naar rechts.
\end{lstlisting}

% == SOFTWARE == %
\section{Software} % ok demo2!
\label{sec:softw}
De software bestaat uit twee delen: een project dat op de NXT van de robot loopt en een project dat op de computer loopt. Alles wordt aangestuurd via de Graphical User Interface (GUI). Deze toepassing laat toe de robot te besturen (via bluetooth) en de reacties van de robot te simuleren met de simulator. Een Communication-pakket stuurt de commando's van de GUI door naar de juiste unit.
De simulator kan gebruikt worden om de software op te testen zonder telkens op de robot te moeten wachten.

% == software design == %
\subsection{Software ontwerp} % ok demo2!
\label{ssec:Sdesign}
Zoals reeds vermeld bestaat de software uit twee projecten: \'e\'en draait op een computer en \'e\'en draait op de NXT-Brick. Figuren 4 en 5 tonen een klassendiagram.\\
Beide projecten hebben een identiek package \textit{commands} met \'e\'en klasse \textit{Command}. Hierin staan de final static integers die met de mogelijke bluetoothsignalen overeenkomen. Een verdere beschrijving van de software op de NXT-brick wordt in de sectie robot gegeven.\\
Het computerproject heeft nog 4 andere packages: \textit{communication}, \textit{gui}, \textit{simulator} en \textit{mapping}. 
De klasse \textit{SilverSurferGUI} uit de package \textit{gui} implementeert de GUI. De GUI communiceert met de simulator of de robot via de klassen in het package \textit{communication} door een object van de superklasse \textit{UnitCommunicator} bij te houden. Aan deze \textit{UnitCommunicator} is een object van de subklassen \textit{RobotCommunicator} of \textit{SimulatorCommunicator}  toegekend. Zo worden de commands dynamisch naar de juiste unit gestuurd: de \textit{RobotCommunicator} communiceert met het NXT-Project, de \textit{SimulatorCommunicator} met de simulator klassen.\\
Andere klassen van de package \textit{gui} zijn: \textit{MouseClickThread} , \textit{PolygonDrawThread}, \textit{RunForwardThread} en \textit{TurnAngleThread}. De vier Threads zorgen ervoor dat het tekenen van de baan van de robot de rest van het programma niet stillegt. \\
Het package \textit{simulator} implementeert de functionaliteit van de simulator. \\
Het \textit{mapping-package} heeft klassen zoals \textit{Tile, Edge, Obstruction, Barcode, ...} die elementen uit de wereld van een robot voorstellen. Een tile stemt overeen met \'e\'en tegel van het doolhof en heeft vier edges: \'e\'en voor elke zijde. Die edges houden de twee aanliggende tegels bij en eventueel een Obstruction, bijvoorbeeld een muur. De klasse \textit{MapGraph} brengt al deze elementen samen. Het houdt een begin-tegel bij en en huidige-tegel. Het biedt functionaliteiten aan om van de huidige tegel naar de tegel Noord, Oost, Zuid of West ervan te reizen en de map dynamisch uit te breiden. Zo wordt impliciet een hele graaf bijgehouden die dynamisch kan aangevuld worden. De klasse \textit{MapReader} kan uit een bepaalde textfile een MapGraph opstellen die overeenkomt met het doolhof dat in het bestand gedefinieerd wordt.


%figuur klassendiagram PC
\begin{figure}[tbp]
\begin{center}
    \includegraphics[width=0.8\textwidth]{KlassendiagramPC}
    \caption{Klassendiagram van de software die op de PC loopt}
    \label{fig:klasDiaPC}
\end{center}
\end{figure}

%figuur klassendiagram NXT
\begin{figure}[tbp]
\begin{center}
    \includegraphics[width=0.8\textwidth]{KlassendiagramNXT}
    \caption{Klassendiagram van de software die op de robot loopt}
	\label{fig:klasDiaNXT}
\end{center}
\end{figure}

% == commando's == %
\subsection{Het doorgeven van commando's}
\label{ssec:commands}
De GUI zet een actie van de gebruiker om in een commando. Dit commando wordt gerepresenteerd door een integer dat naar de \textit{UnitCommunicator} wordt gestuurd. Twee van de commando's hebben echter extra informatie nodig: \textit{automatic move x cm forward} en \textit{rotate x degrees}. Deze informatie wordt toegevoegd aan de integer door de integer uit te breiden met extra cijfers (dit wordt in de volgende sectie in detail beschreven).\\
De \textit{UnitCommunicator} stuurt de bekomen integer door naar ofwel de \textit{RobotCommunicator} ofwel de \textit{SimulatorCommunicator}. Deze zetten de integer weer om in de juiste actie van respectievelijk de robot en de simulator. De wijze waarop dit gebeurt, verschilt licht voor beide gevallen. Zo stuurt de \textit{RobotCommunicator} zijn commando's via Bluetooth door naar de NXT-brick, terwijl de \textit{SimulatorCommunicator} zo'n verbinding niet nodig heeft.\\

\subsubsection{De bewerking op de integers} % ok demo2!
\label{sssec:integer}
Integers stellen de commando's voor. In twee gevallen is echter meer informatie nodig: om de robot een bepaalde afstand te laten afleggen en om de robot een bepaald aantal graden te laten draaien. Deze afstand en dit aantal graden moet mee doorgegeven worden met de integer. De eenheden waarin de afstand en de hoek worden doorgestuurd zijn respectievelijk cm en graden.\\\\
De doorgegeven integer wordt als volgt opgebouwd:

\begin{itemize}
\item de waarde van de afstand (hoek) wordt vermenigvuldigd met 1000.
\item de integer die het commando representeert, wordt hierbij opgeteld.
\end{itemize}

Om de bekomen resultaten terug op te splitsen in de twee oorspronkelijke gegevens worden volgende stappen gevolgd:

\begin{itemize}
\item een modulo-operatie van tien geeft het laatste cijfer terug. Dit stelt het soort commando voor.
\item dit getal wordt van de integer terug afgetrokken.
\item de oorspronkelijke afstand (hoek) wordt bekomen door de integer door 1000 te delen.
\end{itemize}

Deze werkwijze brengt een beperking met zich mee: de waarde van de afstand (hoek) kan slechts tot 2 cijfer(s) na de komma doorgegeven worden. De robot kan niet nauwkeuriger dan 0,1 cm aangestuurd worden. Hierdoor is het niet nodig de afstand nauwkeuriger door te geven. De nauwkeurigheid van de hoek is gevoeliger. De veelhoek stapelt immers veel afrondingsfouten op naarmate de lengte van de zijde en/of het aantal hoeken stijgt. Doordat de begin- en eindpunten niet samen vallen is te zien dat de som van de berekende hoeken samen geen 360 graden vormt. 

% == gui == %
\subsection{GUI} % klopt mss niet met nieuwste gui demo2?
\label{ssec:GUI}
De GUI bestaat uit twee vensters, enkele knoppen, een menubar en enkele instelmogelijkheden: zie figuur \ref{fig:gui}. Deze knoppen besturen ofwel de robot en de simulator ofwel enkel de simulator, naargelang de bluetooth verbinding aan staat. In deze sectie wordt verder enkel de robot vermeld. Dezelfde functionaliteiten gelden echter ook voor de simulator.

%overzicht functionaliteiten
\begin{itemize}
\item \textit{onderste venster:} debuginformatie van de robot.
\item \textit{bovenste venster:} tekent de baan van de robot. In latere demo's geeft dit venster ook de doolhof weer.
\item \textit{bluetooth connectieknop:} zet de verbinding aan of uit. Het icoontje ernaast verandert naargelang de status van de verbinding.
\item \textit{veelhoekinstellingen:} stellen de parameters van de veelhoek in. De 'Execute'-knop doet de robot een veelhoek rijden.
\item \textit{pijltjestoetsen:} besturen de robot manueel.
\item \textit{snelheidsinstellingen:} hiermee kan de snelheid van de robot aangepast worden.
\item \textit{clearknop:} wist de baan van de robot.
\item \textit{moveknop:} rij een bepaalde afstand vooruit of achteruit.
\item \textit{turnknop:} draai 90 graden naar rechts.
\item \textit{menubar:} submenu 'File' biedt de mogelijkheid om een doolhof-bestand te selecteren en in te lezen. Submenu 'Bluetooth' heeft dezelfde functionaliteit als de bluetooth-knop.
\end{itemize}

Twee parameters bepalen de veelhoek die de robot rijdt: het aantal hoeken van de figuur en de lengte van de zijden.
Een JSlider laat toe het aantal hoeken in te geven. Dit geeft de mogelijkheden overzichtelijk weer. Bovendien kan zo het bereik beperkt worden tot 30. Bij een groter aantal hoeken, streeft een veelhoek immers naar een cirkel.
Het bereik van de lengte van de zijden is groter: van \'e\'en centimeter tot een onbeperkte grootte. Hierdoor is het een betere optie om voor JSpinner te kiezen. Met de clearknop kan men het venster weer leeg maken. Hierbij wordt de positie van de robot behouden.
Voor de moveknop is er een Jslider voorzien net zoals voor de polygonDraw. Hiermee kan de afstand ingesteld worden dat de robot naar achter of naar voor moet rijden.

%figuur gui
\begin{figure}[tbp]
\begin{center}
    \includegraphics[width=0.8\textwidth]{GUI}
    \caption{Grafische User Interface}
	\label{fig:gui}
\end{center}
\end{figure}

% == bluetooth == %
\subsection{Bluetooth} % ok demo2!
\label{ssec:bluetooth}
De communicatie tussen robot en computer gebeurt volledig via bluetooth. De GUI voorziet een knop om deze verbinding te maken en geeft de status van de verbinding weer. De GUI stuurt commando's door naar de robot via de klassen \textit{UnitCommunicator} en \textit{RobotCommunicator}.

De leJOS-API\footnote{\textit{leJOS}:  Een kleine Java Virtuele Machine die toelaat de NXT-brick te programmeren. leJOS voorziet verschillende klassen die o.a. de motoren aansturen en een bluetoothverbinding opzetten.  \mbox{[http://lejos.sourceforge.net/]}} voorziet de \textit{NXTConnector} klasse. De methode \textit{connectTo((String, String, int, int)} zet de bluetoothverbinding tussen computer en brick op. De belangrijkste argumenten hiervoor zijn de naam van de NXT-Brick en zijn DeviceUrl  - in het geval van de gebruikte NXT: 'Silver' en '00:16:53:0A:04:5A'.

% == robot == %
\subsection{Robot} % deel over witte lijnen demo2?
\label{ssec:robot}
Een \textit{Finite State Machine} geeft de robot een concreet uitvoeringsschema. Een object van de klasse \textit{CommandUnit} houdt een currentState bij - een object van de superklasse \textit{State}. Negen subklassen verzorgen het nodige onderscheid: \textit{Waiting}, \textit{DrivingBackward}, \textit{TurnLeft}, \textit{DrivingRightForward}, …  en \'e\'en speciale toestand: de klasse \textit{Automatic}. De \textit{CommandUnit} ontvangt commando's via bluetooth. De \textit{CommandUnit} wijzigt de currentState naar een nieuw object van een \textit{State}-subklasse. De constructoren van elke subklasse passen het gedrag van de motoren aan bij de overgang naar de bepaalde state.
Bijvoorbeeld: De robot staat stil en zijn currentState is \textit{Waiting}.
Als de gebruiker de robot voorwaarts wil laten gaan, drukt hij de up-toets in. De \textit{CommandUnit} wijzigt de currentState van de robot naar currentState.ForwardPressed(). Dit levert een currentState van het type \textit{DrivingForward} op. De robot beweegt voorwaarts.
Tot slot is er de klasse \textit{Automatic}. Deze heeft vier methoden: \textit{turnAngle(int)}, \textit{driveForward(int)}, \textit{forwardToWhiteLine(LightSensor)} en \textit{whiteLinePerpendicular(LightSensor)}. De \textit{CommandUnit} roept deze methoden op met argumenten die hij geparsed heeft uit de informatie van de ontvangen signalen, zoals beschreven in sectie \ref{ssec:commands}.

% == simulator == %
\subsection{Simulator} % nog niet up-to-date demo2?
\label{ssec:simulator}
De simulator bootst de werking van de robot virtueel na. Hij kan dezelfde commando's uitvoeren als de werkelijke robot. De GUI stuurt de simulator aan via de klassen \textit{UnitCommunicator} en \textit{SimulatorCommunicator}. Deze ontvangen de uit te voeren commando's, analyseren ze en sturen ze door naar de simulator.
\\
De simulator zelf bestaat uit vier klassen:

% overzicht klassen simulator
\begin{itemize}
\item \textit{SimulationPilot:} houdt de positie en de richting van de 'robot' bij.
\item \textit{SimulationPanel:} tekent de baan van de 'robot' in het tekenpaneel.
\item \textit{GridDrawer:} zet het grid op.
\item \textit{Triangle:} berekent de hoekpunten van de driehoek die de 'robot' voorstelt.
\item \textit{ExtMath:} doet enkele berekeningen.
\end{itemize}

Het opzetten van het tekenpaneel gebeurt in de klasse \textit{SilverSurferGUI}. De klasse \textit{GridDrawer} voegt hier een grid aan toe. De roosters hebben dezelfde afmetingen als de secties van de panelen. Zo kan een muur enkel op een lijn van het grid staan.
Wanneer de 'robot' een pad aflegt, tekent de simulator dit in het tekenpaneel als een rode lijn (herschaald: \'e\'en cm = \'e\'en pixel). De lijn  bestaat uit verschillende cirkels die elkaar gedeeltelijk overlappen. Het \textit{SimulationPanel} houdt alle bezochte co\"ordinaten bij. De klasse bevat een methode die deze cirkels \'e\'en na \'e\'en tekent. Dit zorgt ervoor dat de lijn continu bijgewerkt wordt. De huidige positie en de huidige orientatie van de 'robot' wordt bovenaan het simulatorpaneel in de GUI weergegeven.

% == BESLUIT == %
\section{Besluit} % ok demo2!
\label{sec:besl}
De uiteindelijke fysieke bouw van de robot bestaat uit de NXT, de wielen met aandrijvingen, een ultrasone sensor, een lichtsensor en twee druksensoren.
De calibratie van de robot zorgt ervoor dat hij precies aangestuurd kan worden en dat de sensoren waarden teruggeven die overeenkomen met de werkelijkheid.
De GUI gebruikt een eenvoudige interface en bevat knoppen waarmee de robot handmatig bestuurd kan worden. Door het ingeven van parameters in de GUI kan de robot een willekeurige veelhoek rijden. De uitleeswaarden van de sensoren vertellen de gebruiker wat de robot 'ziet'. Op deze manier krijgt de gebruiker een idee over de doolhof waar de robot in rijdt. Bovendien kan de robot zich loodrecht ori\"enteren op een witte lijn. De simulator is ook verbonden aan de GUI. Deze voert dezelfde opdracht uit als de robot. Het is mogelijk een virtueel doolhof te laten en de simulator hier in te laten 'rijden'. De simulator is handig om testen op uit te voeren, zonder steeds op de robot te moeten wachten.


\newpage
\makeappendix

% == DEMO 1 == %
\section{Demo 1} % ok demo2!
\label{Asec:demo1}
De robot wordt voor demo 1 nog niet voorzien van sensoren. De focus ligt vooral op de nauw-
keurigheid van de besturing en op het implementeren van alle softwarecomponenten. Deze software
bestaat uit twee projecten: een op de computer en een op de robot. De computersoftware bestaat
uit een Grafical User Interface (GUI), enkele Communication klassen die informatie doorsturen en
enkele klassen die de werking van de robot simuleren (simulator).

% == resulaten == %
\subsection{Resultaten} % ok demo2!
\label{Assec:result1}
Bij het rijden van de veelhoek had de robot een kleine afwijking. De afwijking werd groter bij grotere veelhoeken en meerdere hoeken om wille van de geaggregeerde fout.

% == conclusies == %
\subsection{Conclusies} % ok demo2!
\label{Assec:conc1}
Calibratie moet meer getest worden. De GUI kan gebruiksvriendelijker, ook moet het scherm van de simulator herschaald worden, zodat de lijn van simulator nog wordt weergegeven als de simulator van de robot uit het scherm gaat.

% == aanpassingen == %
\subsection{Oplijsting aanpassingen verslag}
\label{Assec:aanp1}
Volgende secties werden aangepast ten opzichte van de eerste demonstratie:

% overzicht aangepaste secties
\begin{itemize}
\item \textit{\ref{ssec:fysbouw} Fysieke bouw:} de sensoren werden toegevoegd.
\item \textit{\ref{ssec:calibM} Calibratie van de motoren:} opnieuw gedaan.
\item \textit{\ref{ssec:calibLS} Calibratie van de lichtsensor:} nieuwe sectie.
\item \textit{\ref{ssec:calibUS} Calibratie van de ultrasone sensor:} nieuwe sectie.
\item \textit{\ref{ssec:algoVeelH} Het rijden van een veelhoek:} nieuwe sectie.
\item \textit{\ref{ssec:algoWitteL} Het rechtzetten op een witte lijn:} nieuwe sectie.
\item \textit{\ref{ssec:Sdesign} Software ontwerp:} enkele nieuwe klassen en mapping-package.
\item \textit{\ref{ssec:GUI} GUI:} enkele nieuwe functionaliteiten.
\item \textit{\ref{ssec:simulator} Simulator:} grid en triangle, virtuele doolhof.
\end{itemize}

\newpage
\bibliographystyle{siam}
\bibliography{biblio.bib}

\end{document}

